{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Origami Origami is a Maven plugin which allows of generation Java RESTful microservices using its description in OpenAPI (Swagger) Specification format from standalone JSON file or being produced by any remote service description provider. Attention This plugin is experimental and should not be used in production.","title":"Home"},{"location":"#origami","text":"Origami is a Maven plugin which allows of generation Java RESTful microservices using its description in OpenAPI (Swagger) Specification format from standalone JSON file or being produced by any remote service description provider. Attention This plugin is experimental and should not be used in production.","title":"Origami"},{"location":"all-you-need-is-pom/","text":"All you need is POM Another part of generation microservices with Origami is plugin configuration. All the configuration preferences must be described in plugin configuration section in the project descriptor pom.xml . Let's add Origami plugin to plugins section in our project pom.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <plugin> <groupId> com.github </groupId> <artifactId> origami-maven-plugin </artifactId> <version> ${origami-plugin.version} </version> <executions> <execution> <phase> generate-sources </phase> <goals> <goal> generate-service </goal> </goals> </execution> <configuration> <!-- configuration should be here --> </configuration> </executions> </plugin> There are two main parts of the plugin configuration: common preferences and transformations . Common preferences section has not its own XML tag and includes following configuration items: 1 2 3 4 5 6 7 8 9 10 11 12 <configuration> <projectOutputDirectory> ${project.build.directory}/generated-sources/swagger </projectOutputDirectory> <sourcesDirectory> /src/main/java </sourcesDirectory> <basePackage> ${project.groupId}.${project.artifactId} </basePackage> <controllerPackage> api </controllerPackage> <modelPackage> model </modelPackage> <configurationPackage> invoker </configurationPackage> <dbType> mongo </dbType> <transformations> ... </transformations> </configuration> with following default values (might be ignored): XML tag Default value projectOutputDirectory ${project.build.directory}/generated-sources/swagger sourcesDirectory /src/main/java basePackage ${project.groupId}.${project.artifactId} controllerPackage api modelPackage model configurationPackage invoker dbType -- transformations N/A Transformations section structure: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <configuration> ... <transformations> <transformation> <sourceDirectory> ${project.build.directory}/generated-sources/swagger/src/main/java </sourceDirectory> <sourceClassPackage> io.swagger.configuration </sourceClassPackage> <sourceClassName> SwaggerDocumentationConfig </sourceClassName> <targetClassPackage> io.swagger.configuration </targetClassPackage> <targetClassName> Swagger2SpringBoot </targetClassName> <targetDirectory> ${project.build.directory}/generated-sources/swagger/src/main/java </targetDirectory> <processingSchemaLocation> ${project.basedir}/src/main/resources </processingSchemaLocation> <processingSchemaClass> SchemaClassName </processingSchemaClass> <transformationProperties> <transformationProperty> <name> propertyName </name> <value> propertyValue </value> </transformationProperty> <!-- another transformation properties --> </transformationProperties> <dependencies> <dependency> <groupId> ... </groupId> <artifactId> ... </artifactId> <version> ... </version> </dependency> </dependencies> </transformation> <!-- another transformations --> </transformations> </configuration> with following default values (might be ignored): XML tag Default value sourceDirectory ${project.build.directory}/generated-sources/swagger/src/main/java sourceClassPackage io.swagger.configuration sourceClassName SwaggerDocumentationConfig targetClassPackage io.swagger.configuration targetClassName Swagger2SpringBoot targetDirectory ${project.build.directory}/generated-sources/swagger/src/main/java processingSchemaLocation ${project.basedir}/src/main/resources processingSchemaClass SchemaClassName transformationProperties N/A dependencies N/A transformationProperties contains key and value pairs that can be used in schema (you can get a property value by its name using Context object).","title":"All you need is POM"},{"location":"all-you-need-is-pom/#all-you-need-is-pom","text":"Another part of generation microservices with Origami is plugin configuration. All the configuration preferences must be described in plugin configuration section in the project descriptor pom.xml . Let's add Origami plugin to plugins section in our project pom.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <plugin> <groupId> com.github </groupId> <artifactId> origami-maven-plugin </artifactId> <version> ${origami-plugin.version} </version> <executions> <execution> <phase> generate-sources </phase> <goals> <goal> generate-service </goal> </goals> </execution> <configuration> <!-- configuration should be here --> </configuration> </executions> </plugin> There are two main parts of the plugin configuration: common preferences and transformations . Common preferences section has not its own XML tag and includes following configuration items: 1 2 3 4 5 6 7 8 9 10 11 12 <configuration> <projectOutputDirectory> ${project.build.directory}/generated-sources/swagger </projectOutputDirectory> <sourcesDirectory> /src/main/java </sourcesDirectory> <basePackage> ${project.groupId}.${project.artifactId} </basePackage> <controllerPackage> api </controllerPackage> <modelPackage> model </modelPackage> <configurationPackage> invoker </configurationPackage> <dbType> mongo </dbType> <transformations> ... </transformations> </configuration> with following default values (might be ignored): XML tag Default value projectOutputDirectory ${project.build.directory}/generated-sources/swagger sourcesDirectory /src/main/java basePackage ${project.groupId}.${project.artifactId} controllerPackage api modelPackage model configurationPackage invoker dbType -- transformations N/A Transformations section structure: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 <configuration> ... <transformations> <transformation> <sourceDirectory> ${project.build.directory}/generated-sources/swagger/src/main/java </sourceDirectory> <sourceClassPackage> io.swagger.configuration </sourceClassPackage> <sourceClassName> SwaggerDocumentationConfig </sourceClassName> <targetClassPackage> io.swagger.configuration </targetClassPackage> <targetClassName> Swagger2SpringBoot </targetClassName> <targetDirectory> ${project.build.directory}/generated-sources/swagger/src/main/java </targetDirectory> <processingSchemaLocation> ${project.basedir}/src/main/resources </processingSchemaLocation> <processingSchemaClass> SchemaClassName </processingSchemaClass> <transformationProperties> <transformationProperty> <name> propertyName </name> <value> propertyValue </value> </transformationProperty> <!-- another transformation properties --> </transformationProperties> <dependencies> <dependency> <groupId> ... </groupId> <artifactId> ... </artifactId> <version> ... </version> </dependency> </dependencies> </transformation> <!-- another transformations --> </transformations> </configuration> with following default values (might be ignored): XML tag Default value sourceDirectory ${project.build.directory}/generated-sources/swagger/src/main/java sourceClassPackage io.swagger.configuration sourceClassName SwaggerDocumentationConfig targetClassPackage io.swagger.configuration targetClassName Swagger2SpringBoot targetDirectory ${project.build.directory}/generated-sources/swagger/src/main/java processingSchemaLocation ${project.basedir}/src/main/resources processingSchemaClass SchemaClassName transformationProperties N/A dependencies N/A transformationProperties contains key and value pairs that can be used in schema (you can get a property value by its name using Context object).","title":"All you need is POM"},{"location":"context-is-for-kings/","text":"Context is for Kings Processing Schemas can use any data contained in Context in a type-safe way: context.get([property_name], [value_class]) For example, in the schema below we request some data from Processing Context : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SomeProcessingSchema implements ASTProcessingSchema { @Override public BiFunction < CompilationUnit , Context , CompilationUnit > preProcessCompilationUnit () { return ( CompilationUnit n , Context context ) -> { var model = context . get ( PIPELINE_ID . name (), Name . class ); var dbType = context . get ( DB_TYPE . name (), Storage . DbType . class ); var varFromTransformation = context . get ( \"varFromTransformation\" , String . class ); // some code return n ; }; } } Of course, the schema must know about the type of the data contained in context. It means that you should add such classes as Name.class , Storage.class to classpath of Origami to process SomeProcessingSchema . Note that property varFromTransformation was initialized in <transformationProperty> section in pom.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <configuration> ... <transformations> <transformation> ... <processingSchemaClass> SomeProcessingSchema </processingSchemaClass> <transformationProperties> <transformationProperty> <name> varFromTransformation </name> <value> HelloFromTransformation </value> </transformationProperty> <!-- another transformation properties --> </transformationProperties> </transformation> <!-- another transformations --> </transformations> </configuration>","title":"Context is for Kings"},{"location":"context-is-for-kings/#context-is-for-kings","text":"Processing Schemas can use any data contained in Context in a type-safe way: context.get([property_name], [value_class]) For example, in the schema below we request some data from Processing Context : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SomeProcessingSchema implements ASTProcessingSchema { @Override public BiFunction < CompilationUnit , Context , CompilationUnit > preProcessCompilationUnit () { return ( CompilationUnit n , Context context ) -> { var model = context . get ( PIPELINE_ID . name (), Name . class ); var dbType = context . get ( DB_TYPE . name (), Storage . DbType . class ); var varFromTransformation = context . get ( \"varFromTransformation\" , String . class ); // some code return n ; }; } } Of course, the schema must know about the type of the data contained in context. It means that you should add such classes as Name.class , Storage.class to classpath of Origami to process SomeProcessingSchema . Note that property varFromTransformation was initialized in <transformationProperty> section in pom.xml : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <configuration> ... <transformations> <transformation> ... <processingSchemaClass> SomeProcessingSchema </processingSchemaClass> <transformationProperties> <transformationProperty> <name> varFromTransformation </name> <value> HelloFromTransformation </value> </transformationProperty> <!-- another transformation properties --> </transformationProperties> </transformation> <!-- another transformations --> </transformations> </configuration>","title":"Context is for Kings"},{"location":"inside-out/","text":"Origami. Inside out Origami contains a Finite-state machine under the hood. It considers all the registered Processing stages (of both types internal and external ) as the set of available states and moves from one the another according to the order they were registered. Basically, you cannot affect to the internal stages' order itself, but you allow to change any line of code produced by internal schemas' processing. Be sure that you register the schemas in the same order that you expect in the code of each of them. In example, a class being generated in schema A and being used in schema B must be available at the moment when schema B will be processed. That means an order for schema registration A before B .","title":"Origami. Inside out"},{"location":"inside-out/#origami-inside-out","text":"Origami contains a Finite-state machine under the hood. It considers all the registered Processing stages (of both types internal and external ) as the set of available states and moves from one the another according to the order they were registered. Basically, you cannot affect to the internal stages' order itself, but you allow to change any line of code produced by internal schemas' processing. Be sure that you register the schemas in the same order that you expect in the code of each of them. In example, a class being generated in schema A and being used in schema B must be available at the moment when schema B will be processed. That means an order for schema registration A before B .","title":"Origami. Inside out"},{"location":"that-was-its-name/","text":"That was its name A cornerstone of Origami is a Processing Schema . There are two logically separated types of schemas: internal- and external- ones. Each of them describes the changes of the source code in terms of abstract syntax tree nodes that could be processed and applied to the linked target .class file. Internal processing schema describes a peace of changes that will be implemented in every single generated microservice. You don't need to worry about this one until you want to change something in a common service stub generated by the plugin. External processing schema is just a chunk of java .class files linked with current microservice repository. It contains some logically connected changes of the source code that are peculiar to the current microservice only . All you need to start development of external schema class is to get origami-api and implement ASTProcessingSchema interface.","title":"That was its name"},{"location":"that-was-its-name/#that-was-its-name","text":"A cornerstone of Origami is a Processing Schema . There are two logically separated types of schemas: internal- and external- ones. Each of them describes the changes of the source code in terms of abstract syntax tree nodes that could be processed and applied to the linked target .class file. Internal processing schema describes a peace of changes that will be implemented in every single generated microservice. You don't need to worry about this one until you want to change something in a common service stub generated by the plugin. External processing schema is just a chunk of java .class files linked with current microservice repository. It contains some logically connected changes of the source code that are peculiar to the current microservice only . All you need to start development of external schema class is to get origami-api and implement ASTProcessingSchema interface.","title":"That was its name"},{"location":"walking-through-the-jungle/","text":"Walking through the jungle Every Processing schema class we made can be imagined as a set of actions with the AST nodes. We can walk from one source code file to another, look through its AST structure and change the nodes according to the 'algorithm' we get from predefined processing schema . There are pre- and post- process actions which can be applied to the currently processed node one-by-one: graph LR A[<b>Node</b> v1] --> |<i>preProcess</i><b>NodeType</b>| B[<b>Node</b> v2]; B --> |<i>postProcess</i><b>NodeType</b>| C[<b>Node</b> v3]; As you can see we can deal with up to 3 different versions of one node during processing the source code and the resulted version of node will be saved to the target .class file. Of course, you can add any operations to your schema action (e.g. logging) or even keep the node's state effectively immutable. Let's take a look to the example of Processing schema declaration: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class SomeProcessingSchema implements ASTProcessingSchema { @Override public BiFunction < CompilationUnit , Context , CompilationUnit > preProcessCompilationUnit () { return ( CompilationUnit n , Context context ) -> { // some code return n ; }; } @Override public BiFunction < CompilationUnit , Context , CompilationUnit > preProcessClassOrInterfaceDeclaration () { return ( ClassOrInterfaceDeclaration n , Context context ) -> { // some code return n ; }; } @Override public BiFunction < ClassOrInterfaceDeclaration , Context , ClassOrInterfaceDeclaration > postProcessClassOrInterfaceDeclaration () { return ( ClassOrInterfaceDeclaration n , Context context ) -> { // some code return n ; }; } } All the operations with the node n must be declared in corresponding BiFunction body. Plugin expects that you will return the same node object that you got as a result of every processing action. According to the \"Convention over configuration\" principle you should declare only the actions you really need to do during the scheme processing.","title":"Walking through the jungle"},{"location":"walking-through-the-jungle/#walking-through-the-jungle","text":"Every Processing schema class we made can be imagined as a set of actions with the AST nodes. We can walk from one source code file to another, look through its AST structure and change the nodes according to the 'algorithm' we get from predefined processing schema . There are pre- and post- process actions which can be applied to the currently processed node one-by-one: graph LR A[<b>Node</b> v1] --> |<i>preProcess</i><b>NodeType</b>| B[<b>Node</b> v2]; B --> |<i>postProcess</i><b>NodeType</b>| C[<b>Node</b> v3]; As you can see we can deal with up to 3 different versions of one node during processing the source code and the resulted version of node will be saved to the target .class file. Of course, you can add any operations to your schema action (e.g. logging) or even keep the node's state effectively immutable. Let's take a look to the example of Processing schema declaration: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class SomeProcessingSchema implements ASTProcessingSchema { @Override public BiFunction < CompilationUnit , Context , CompilationUnit > preProcessCompilationUnit () { return ( CompilationUnit n , Context context ) -> { // some code return n ; }; } @Override public BiFunction < CompilationUnit , Context , CompilationUnit > preProcessClassOrInterfaceDeclaration () { return ( ClassOrInterfaceDeclaration n , Context context ) -> { // some code return n ; }; } @Override public BiFunction < ClassOrInterfaceDeclaration , Context , ClassOrInterfaceDeclaration > postProcessClassOrInterfaceDeclaration () { return ( ClassOrInterfaceDeclaration n , Context context ) -> { // some code return n ; }; } } All the operations with the node n must be declared in corresponding BiFunction body. Plugin expects that you will return the same node object that you got as a result of every processing action. According to the \"Convention over configuration\" principle you should declare only the actions you really need to do during the scheme processing.","title":"Walking through the jungle"}]}